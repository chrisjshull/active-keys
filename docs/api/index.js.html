<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * Copyright (C) 2017 Dremio Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-bitwise: 0 */

/**
 * Base module for active-keys.
 * Default export is singleton instance of KeyWatcher.
 * @module index
 * @example
 * import keyWatcher from 'active-keys';
 * keyWatcher.addEventListener('change', () => {
 *   console.log(keyWatcher.activeKeys);
 * });
 */

import EventTargetShim from 'event-target-shim';

/**
 * Tracks which keys are currently held down.
 */
export class KeyWatcher extends EventTargetShim {

  /**
   * Object of which keyboard keys are currently held down.
   * Object keys are {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values|KeyboardEvent#key}.
   * Object values should be treated as truthy/falsy only.
   * @fires {@link module:index.KeyWatcher#change|change} when updated.
   */
  activeKeys = {};

  /**
   * @method module:index.KeyWatcher#addEventListener
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   */
  /**
   * @method module:index.KeyWatcher#removeEventListener
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
   */

  constructor() {
    super();

    window.addEventListener('keydown', this);
    window.addEventListener('keyup', this);
    window.addEventListener('blur', this);
  }

  _destroy() {
    window.removeEventListener('keydown', this);
    window.removeEventListener('keyup', this);
    window.removeEventListener('blur', this);
  }

  /**
   * @private
   */
  handleEvent(evt) {
    const typeHandler = '_handle' + evt.type[0].toUpperCase() + evt.type.slice(1);
    if (this[typeHandler]) this[typeHandler](evt);
  }

  _handleKeydown({key, location}) {
    let [newKey, changed] = this._handleModifiers(key);
    key = newKey;

    if (key) {
      const wasActive = this.activeKeys[key] = this.activeKeys[key] || 0;
      const bitwise = 1 &lt;&lt; location;

      if (!(this.activeKeys[key] &amp; bitwise)) {
        this.activeKeys[key] |= bitwise;
        if (!wasActive) changed = true;
      }
    }

    changed &amp;&amp; this._dispatch();
  }

  _handleKeyup({key, location}) {
    let [newKey, changed] = this._handleModifiers(key);
    key = newKey;

    if (key) {

      // Safety for browser/OS shortcuts
      // While Chrome might be detected with missing keypress, FF cannot be.
      // So lacking a better idea for now, being a bit aggressive...
      // (Also helps with down:f, down:Alt, up:Alt -> Æ’ type bugs)
      if (this._isNamedKey(key)) {
        changed = this._removeUnnamedKeys();
      }

      if (this.activeKeys[key]) {

        const bitwiseInverse = ~(1 &lt;&lt; location);

        this.activeKeys[key] &amp;= bitwiseInverse;
        if (!this.activeKeys[key]) {
          delete this.activeKeys[key];
          changed = true;
        }
      }
    }

    changed &amp;&amp; this._dispatch();
  }

  _handleBlur() {
    // once the window/tab/frame loses focus we won't get keyup events
    // so err on the side of a full reset.
    // e.g. new tab, app switching, print dialog
    this._removeAll();
  }

  _removeAll() {
    // maintain the object reference
    for (const activeKey of Object.keys(this.activeKeys)) {
      delete this.activeKeys[activeKey];
    }

    this._dispatch();
  }

  _isNamedKey(key) {
    return key.match(/^[A-Z][a-zA-Z0-9]+$/); // named keys match this pattern, while unnamed keys cannot (https://www.w3.org/TR/2017/CR-uievents-key-20170601/)
  }

  _removeUnnamedKeys() {
    let removed = false;
    for (const activeKey of Object.keys(this.activeKeys)) {
      if (this._isNamedKey(activeKey)) continue;
      delete this.activeKeys[activeKey];
      removed = true;
    }
    return removed;
  }

  _handleModifiers(key) {
    // these glyph modifier keys *are* respected, and can cause previously pressed unnamed keys to get "stuck" active
    // so will err on the side of resetting all unnamed keys
    // https://www.w3.org/TR/2017/CR-uievents-key-20170601/#selecting-key-attribute-values
    if (key !== 'Shift' &amp;&amp; key !== 'CapsLock' &amp;&amp; key !== 'AltGraph') {
      // a similar situation can happen when a Dead key is hit.
      // e.g. on a US Mac keyboard;
      // - down:e, down:Alt [down:Dead], up:e (no event), up:alt [up:Dead] -> e
      // - down:e, down:Alt [down:Dead], up:alt, up:e -> Dead
      if (key !== 'Dead') {
        return [key, false];
      }
    }

    const changed = this._removeUnnamedKeys();

    // The Dead key can also get stuck, and it's not a real key, so just ignore it.
    // e.g. on a US Mac keyboard;
    // - down:e, down:Alt [down:Dead], up:alt, up:e -> Dead
    return [key === 'Dead' ? null : key, changed];
  }

  _dispatch() {
    /**
     * Event fired when {@link module:index.KeyWatcher#activeKeys|activeKeys} changes.
     * @event module:index.KeyWatcher#change
     */
    const event = new Event('change', {
      bubbles: false,
      cancelable: false
    });
    this.dispatchEvent(event);
  }

}

export default new KeyWatcher();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-index.html">index</a></li><li><a href="module-react.html">react</a></li></ul><h3>Classes</h3><ul><li><a href="module-index.KeyWatcher.html">KeyWatcher</a></li></ul><h3>Events</h3><ul><li><a href="module-index.KeyWatcher.html#event:change">change</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a> on Sun Oct 01 2017 10:15:44 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
